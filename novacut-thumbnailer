#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
A quick and dirty GStreamer thumbnailer.
"""

import sys
from os import path
import json
from base64 import b64encode
import optparse


parser = optparse.OptionParser(
    usage='%prog FILE_ID [FRAME1...]',
)
(options, args) = parser.parse_args()


if not args:
    print('takes at least 1 argument FILE_ID')
    sys.exit(1)
_id = args[0]

if len(args) == 1:
    frames = [0]
else:
    frames = [int(f) for f in args[1:]]


import dbus
import gi
gi.require_version('Gst', '1.0')
from gi.repository import GObject, Gst
from microfiber import Database, NotFound

from novacut.renderer import make_element
from novacut.timefuncs import frame_to_nanosecond, nanosecond_to_frame


GObject.threads_init()
Gst.init(None)
session = dbus.SessionBus()
Dmedia = session.get_object('org.freedesktop.Dmedia', '/')


KEYFRAME = 15



def get_filename(doc):
    if doc.get('proxies'):
        for _id in doc['proxies']:
            try:
                return Dmedia.Resolve(_id)
            except Exception:
                pass
    return Dmedia.Resolve(doc['_id']) 


env = json.loads(Dmedia.GetEnv())


# See if file is available locally, preferring proxy files:
dmedia_0 = Database('dmedia-0', env)
doc = dmedia_0.get(_id)
try:
    filename = get_filename(doc)
except Exception:
    print('not local:', _id)
    sys.exit(0)
print(filename)

# Thumbnail DB
db = Database('thumbnails', env)
db.ensure()


class Thumbnailer(object):
    def __init__(self, _id, frames, filename):
        try:
            self.doc = db.get(_id)
        except NotFound:
            self.doc = {
                '_id': _id,
                '_attachments': {},
            }
        self.attachments = self.doc['_attachments']
        self.changed = False

        self.count = 0
        self.i = 0
        self.frames = sorted(set(frames))
        self.framerate = None

        self.mainloop = GObject.MainLoop()
        self.pipeline = Gst.Pipeline()

        # Create bus and connect several handlers
        self.bus = self.pipeline.get_bus()
        self.bus.add_signal_watch()
        self.bus.connect('message::eos', self.on_eos)
        self.bus.connect('message::error', self.on_error)

        # Create elements
        self.src = make_element('filesrc', {'location': filename})
        self.dec = make_element('decodebin')
        self.scale = make_element('videoscale', {'method': 3})
        self.enc = make_element('jpegenc', {'quality': 95})
        self.sink = make_element('fakesink', {'signal-handoffs': True})

        # Signals
        self.dec.connect('pad-added', self.on_pad_added)
        self.dec.connect('no-more-pads', self.on_no_more_pads)
        self.sink.connect('handoff', self.on_handoff)

        # Add elements to pipeline
        self.pipeline.add(self.src)
        self.pipeline.add(self.dec)
        self.pipeline.add(self.scale)
        self.pipeline.add(self.enc)
        self.pipeline.add(self.sink)

        # Link elements
        self.src.link(self.dec)
        self.scale.link_filtered(self.enc,
            Gst.caps_from_string('video/x-raw, width=192, height=108')
        )
        self.enc.link(self.sink)

    def seek_to_frame(self, frame):
        print('seek_to_frame', self.frame)
        self.count = 0
        self.pipeline.seek_simple(
            Gst.Format.TIME,
            Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT,
            frame_to_nanosecond(frame, self.framerate)
        )

    def next(self):
        print('next')
        while True:
            if self.i >= len(self.frames):
                GObject.idle_add(self.kill)
                return
            self.frame = self.frames[self.i]
            self.i += 1
            if str(self.frame) in self.attachments:
                print('already have frame', self.frame)
                continue
            else:
                self.seek_to_frame(self.frame)
                return

    def on_pad_added(self, element, pad):
        caps = pad.query_caps(None)
        string = caps.to_string()
        print('on_pad_added', string)
        if string.startswith('video/'):
            self.framerate = caps.get_structure(0).get_fraction('framerate')[1:3]
            print('framerate', self.framerate)
            pad.link(self.scale.get_static_pad('sink'))

    def on_no_more_pads(self, element):
        print('on_no_more_pads')
        self.next()

    def on_handoff(self, element, buf, pad):
        frame = nanosecond_to_frame(buf.pts, self.framerate)
        print('handoff', frame)
        key = str(frame)
        if key not in self.attachments:
            self.changed = True
            map_info = buf.map_range(0, -1, Gst.MapFlags.READ)[1]
            data = map_info.to_bytes().unref_to_array()
            self.attachments[key] = {
                'content_type': 'image/jpeg',
                'data': b64encode(data).decode('ascii'),
            }
        else:
            print('got buffer for frame we arleady have', frame)
        self.count += 1
        if frame >= self.frame and self.count >= KEYFRAME:
            print('done', self.count, frame)
            GObject.idle_add(self.next)

    def run(self):
        self.pipeline.set_state(Gst.State.PLAYING)
        self.mainloop.run()

    def kill(self):
        print('kill')
        self.pipeline.set_state(Gst.State.NULL)
        self.mainloop.quit()

    def on_eos(self, bus, msg):
        print('eos')
        self.kill()

    def on_error(self, bus, msg):
        error = msg.parse_error()[1]
        print(error)
        self.kill()

thumbnailer = Thumbnailer(_id, frames, filename)
thumbnailer.run()
if thumbnailer.changed:
    print('saving changes')
    db.save(thumbnailer.doc)
else:
    print('no changes to save')



