#!/usr/bin/python3

# dmedia: distributed media library
# Copyright (C) 2011 Novacut Inc
#
# This file is part of `dmedia`.
#
# `dmedia` is free software: you can redistribute it and/or modify it under
# the terms of the GNU Affero General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option) any
# later version.
#
# `dmedia` is distributed in the hope that it will be useful, but WITHOUT ANY
# WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
# A PARTICULAR PURPOSE.  See the GNU Affero General Public License for more
# details.
#
# You should have received a copy of the GNU Affero General Public License along
# with `dmedia`.  If not, see <http://www.gnu.org/licenses/>.
#
# Authors:
#   Jason Gerard DeRose <jderose@novacut.com>

"""
A quick and dirty GStreamer thumbnailer.
"""

import sys
from os import path
import json
from base64 import b64encode
import argparse
from fractions import Fraction
import logging

from gi.repository import GLib, Gst

from novacut.renderer import make_element
from novacut.timefuncs import frame_to_nanosecond, nanosecond_to_frame


Gst.init(None)
logging.basicConfig(
    level=logging.DEBUG,
    format='\t'.join([
        '%(levelname)s',
        '%(processName)s',
        '%(threadName)s',
        '%(message)s',
    ]),
)
log = logging.getLogger()
COUNT = 10


class Thumbnailer:
    def __init__(self, filename, frames):
        self.frames = sorted(set(frames))
        self.framerate = None
        self.start = 0
        self.stop = 0

        self.mainloop = GLib.MainLoop()
        self.pipeline = Gst.Pipeline()

        # Create bus and connect several handlers
        self.bus = self.pipeline.get_bus()
        self.bus.add_signal_watch()
        self.bus.connect('message::eos', self.on_eos)
        self.bus.connect('message::error', self.on_error)

        # Create elements
        self.src = make_element('filesrc', {'location': filename})
        self.dec = make_element('decodebin')
        self.dec.set_property('caps', Gst.caps_from_string('video/x-raw'))
        self.scale = make_element('videoscale', {'method': 2})
        self.enc = make_element('jpegenc', {'quality': 95})
        self.sink = make_element('fakesink', {'signal-handoffs': True})

        # Signals
        self.dec.connect('pad-added', self.on_pad_added)
        self.dec.connect('no-more-pads', self.on_no_more_pads)
        self.sink.connect('handoff', self.on_handoff)

        # Add elements to pipeline
        self.pipeline.add(self.src)
        self.pipeline.add(self.dec)
        self.pipeline.add(self.scale)
        self.pipeline.add(self.enc)
        self.pipeline.add(self.sink)

        # Link elements
        self.src.link(self.dec)
        self.scale.link_filtered(self.enc,
            Gst.caps_from_string('video/x-raw, width=192, height=108')
        )
        self.enc.link(self.sink)

    def seek_to_frame(self, frame):
        log.info('seeking to frame %d', frame)
        self.start = frame
        self.stop = frame + COUNT
        self.pipeline.seek_simple(
            Gst.Format.TIME,
            Gst.SeekFlags.FLUSH | Gst.SeekFlags.KEY_UNIT,
            frame_to_nanosecond(frame, self.framerate)
        )

    def next(self):
        while self.frames:
            frame = self.frames.pop(0)
            if frame >= self.stop:
                self.seek_to_frame(frame)
                return
        self.kill()

    def on_pad_added(self, element, pad):
        caps = pad.query_caps(None)
        string = caps.to_string()
        log.info('on_pad_added %s', string)
        if string.startswith('video/'):
            (num, denom) = caps.get_structure(0).get_fraction('framerate')[1:3]
            self.framerate = Fraction(num, denom)
            log.info('framerate: %r', self.framerate)
            pad.link(self.scale.get_static_pad('sink'))

    def on_no_more_pads(self, element):
        log.info('on_no_more_pads')
        GLib.idle_add(self.next)

    def on_handoff(self, element, buf, pad):
        frame = nanosecond_to_frame(buf.pts, self.framerate)
        ns = frame_to_nanosecond(frame, self.framerate)
        if buf.pts != ns:
            log.warning('frame %d buf.pts %d != %d', frame, bufs.pts, ns)
        data = buf.extract_dup(0, buf.get_size())
        log.info('handoff frame %d', frame)
        if frame == (self.stop - 1):
            log.info('done with frames[%d:%d]', self.start, self.stop)
            GLib.idle_add(self.next)

    def run(self):
        self.pipeline.set_state(Gst.State.PLAYING)
        self.mainloop.run()

    def kill(self):
        log.info('kill')
        self.pipeline.set_state(Gst.State.NULL)
        self.mainloop.quit()

    def on_eos(self, bus, msg):
        log.info('eos')
        self.kill()

    def on_error(self, bus, msg):
        log.error(msg.parse_error())
        self.kill()

parser = argparse.ArgumentParser(add_help=False)
parser.add_argument('file')
parser.add_argument('frame', type=int, nargs='+')
args = parser.parse_args()


thumbnailer = Thumbnailer(args.file, args.frame)
thumbnailer.run()
